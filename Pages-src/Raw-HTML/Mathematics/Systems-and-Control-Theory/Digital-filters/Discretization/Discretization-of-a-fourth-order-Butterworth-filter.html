<!--
@title: Discretization of a Fourth-Order Butterworth Filter
@author: Pieter P
@sequence: 20
@keywords: Discretization, bilinear transform, tustin method, digital filters, continuous-time, discrete-time, Butterworth filter
@description: Converting a continuous-time fourth-order Butterworth low-pass filter to a discrete-time filter.
-->
<html>

<p>
This is an example on how to design a filter in the analog domain, 
and then use the bilinear transform to transform it to the digital domain, while preserving the cut-off frequency.
</p>
<p>
We'll be using formulas derived on the <a href="Bilinear-transform.html">Bilinear Transform</a> 
and <a href="../../Analog-Filters/Butterworth-Filters.html">Butterworth Filters</a> pages.
</p>

<h3>Design criteria</h3>

<p>
    In this example, we'll design a digital fourth order Butterworth low-pass filter, with a sample frequency of \(360 \;\mathrm{Hz}\) 
    and a cut-off frequency of \(45 \;\mathrm{Hz}\).
</p>

<h3>Frequency Pre-Warping</h3>
<p>
As discussed in the page on the Bilinear Transform, we have to apply pre-warping to the cut-off frequency before designing a filter.
If we don't the cut-off frequency will shift to an incorrect frequency when we discretize the filter.
</p>
<p>
    First, let's calculate the normalized digital frequency \(\omega_{c,d}\), using the cut-off frequency \(f_c\) and the sample frequency \(f_s\):
    $$ \begin{split} 
        f_c &= 45 \;\mathrm{Hz} \\
        f_s &= 360 \;\mathrm{Hz} \\
        T_s &= \frac{1}{f_s} \\
        \omega_c &= 2\pi f_c \\
                 &\approx 282.7 \;\mathrm{rad} \;s^{-1} \\
        \omega_{c,d} &= \frac{\omega_c}{f_s} \\
                     &= \frac{\pi}{4} \frac{\mathrm{rad}}{\mathrm{sample}} \approx 0.7854 \frac{\mathrm{rad}}{\mathrm{sample}}
    \end{split}
    $$
    The Nyquist-Shannon sampling theorem tells us that we can never sample frequencies higher than \(f_s/2\) without losing information. 
    This also means that the cut-off frequency can never be higher than half of the sample frequency. 
    Or in other words, all normalized frequencies will be in the interval \([0, \pi]\).
</p>
<p>
    Next, we'll use the pre-warping formula we derived in the page on the Bilinear Transform, in order to calculate the analog design frequency \(\omega_{c,a}\):
    $$ \begin{split}
        \omega_{c,a} &= \frac{2}{T_s}\tan\left(\frac{\omega_{c,d}}{2}\right) \\
                     &= 720 \tan\left(\frac{\pi}{8}\right) \approx 298.2 \;\mathrm{rad} \;s^{-1} 
        \end{split} $$
    Note that this frequency is relatively close to \(\omega_c\), but it is <em>not</em> the same. 
    The higher the cut-off frequency (relative to the sample frequency), the larger the error between \(\omega_c\) and \(\omega_{c,a}\).
</p>

<h3>Designing the Butterworth filter in the Analog Domain</h3>

<p>
    Now that we know the pre-warped analog cut-off frequency, we can start designing the analog filter.<br>
    We'll use the formula for the Butterworth low-pass filter derived in the page on Butterworth Filters:
    $$ \begin{equation} H_4(s') = \frac{1}{B_4(s')} \quad\quad \mathrm{where} \;s' \triangleq \frac{s}{\omega_{c,a}} \label{H} \end{equation} $$

    $$ B_4(s') = \left(s'^2 - 2\cos\left(2\pi\frac{4+1}{4\cdot4}\right) s' + 1\right)
                 \left(s'^2 - 2\cos\left(2\pi\frac{2+4+1}{4\cdot4}\right) s' + 1\right) $$

    Defining these constants will make the calculations much easier:
    $$ \begin{align} 
    \begin{split}
    \alpha &\triangleq -2\cos\left(\frac{5\pi}{8}\right) \\
           &= \sqrt{2 - \sqrt{2}} \\
    \end{split} \label{alpha} \\
    \begin{split}
    \beta &\triangleq -2\cos\left(\frac{7\pi}{8}\right) \\
          &= \sqrt{2 + \sqrt{2}}
    \end{split} \label{beta}
    \end{align} $$
    $$ \begin{equation} \begin{split} 
    B_4(s') &= \left(s'^2 + \alpha s' + 1\right)\left(s'^2 + \beta s' + 1\right) \\ 
            &= s'^4 + s'^3(\alpha+\beta) + s'^2(\alpha\beta+2) + s'(\alpha+\beta) + 1
    \end{split} \label{B} \end{equation} $$
</p>

<h3>Discretizing the Analog Filter</h3>

<p>
    We can now just apply the Bilinear Transform to the analog transfer function, by substituting \(s = \frac{2}{T_s}\frac{z-1}{z+1}\).
    Therefore:
    $$ s' = \frac{2 f_s}{\omega_{a,c}}\frac{z-1}{z+1} $$
    Again, we'll introduce a constant to simplify the expression:
    $$ \begin{equation}\label{gamma} \begin{split}
    \gamma &\triangleq \frac{2 f_s}{\omega_{a,c}} = \frac{2f_s}{2f_s\tan\left(\frac{\omega_{c,d}}{2}\right)} = \cot\left(\pi\frac{f_c}{f_s}\right) \\
    &= \cot\left(\frac\pi8\right) = 1 + \sqrt2 \end{split} \end{equation} $$
    $$ \begin{equation} s' = \gamma \frac{z-1}{z+1} \label{s_prime_z} \end{equation} $$

    What follows is just rearranging the expression of \(B_4(s')\) from Equation \(\ref{B}\), using the substitution of Equation \(\ref{s_prime_z}\).<br>
    Finally, we end up with an expression for the transfer function, using Equation \(\ref{H}\), and we can determine the coefficients using the constants 
    defined in Equations \(\ref{alpha}\), \(\ref{beta}\) &amp; \(\ref{gamma}\).

    $$ \begin{split} 
        B_4(s') \;\;= \;\;& s'^4 + s'^3(\alpha+\beta) + s'^2(\alpha\beta+2) + s'(\alpha+\beta) + 1 \\[1em]
        B_4(z) \;\;= \;\;& \gamma^4 \frac{(z-1)^4}{(z+1)^4} \\
                       & + \gamma^3 \frac{(z-1)^3 (z+1)}{(z+1)^4} (\alpha+\beta) \\
                       & + \gamma^2 \frac{(z-1)^2 (z+1)^2}{(z+1)^4} (\alpha\beta+2) \\
                       & + \gamma \frac{(z-1) (z+1)^3}{(z+1)^4} (\alpha+\beta) \\
                       & + \frac{(z+1)^4}{(z+1)^4} \\[1em]
                = \;\;& \frac{1}{(z+1)^4} \left[ \begin{array}[l]
                    \;&\gamma^4 (z-1)^4 \\
                    +& \gamma^3 (z-1)^3 (z+1) (\alpha+\beta) \\
                    +& \gamma^2 (z-1)^2 (z+1)^2 (\alpha\beta+2) \\
                    +& \gamma (z-1) (z+1)^3 (\alpha+\beta) \\
                    +& (z+1)^4
                    \end{array}\right] \\
                = \;\;& \frac{1}{(z+1)^4} \left[ \begin{array}[l]
                    \;& \gamma^4 &(&z^4 &-& 4z^3 &+& 6z^2 &-& 4z &+& 1&) \\ 
                    +& \gamma^3 &(&z^4 &-& 2z^3 & &      &+& 2z &-& 1&)&(\alpha+\beta) \\
                    +& \gamma^2 &(&z^4 & &      &-& 2z^2 & &    &+& 1&)&(\alpha\beta+2) \\
                    +& \gamma   &(&z^4 &+& 2z^3 & &      &-& 2z &-& 1&)&(\alpha+\beta) \\
                    +&          &(&z^4 &+& 4z^3 &+& 6z^2 &+& 4z &+& 1&)  
                    \end{array} \right] \\
                = \;\;& \frac{1}{(z+1)^4} \left[ \begin{array}[l]
                    \;&\left(\gamma^4+\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)+\gamma(\alpha+\beta)+1\right) & z^4 \\ 
                    +&\left(-4\gamma^4-2\gamma^3(\alpha+\beta)+2\gamma(\alpha+\beta)+4\right)                    & z^3 \\ 
                    +&\left(6\gamma^4-2\gamma^2(\alpha\beta+2)+6\right) & z^2 \\ 
                    +&\left(-4\gamma^4+2\gamma^3(\alpha+\beta)-2\gamma(\alpha+\beta)+4\right) & z \\
                    +&\left(\gamma^4-\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)-\gamma(\alpha+\beta)+1\right)
                    \end{array} \right] \\[1em]
        H_{4}(z) \;\;= \;\;& \frac{1}{B_4(z)} \\
                     = \;\;& \frac{(z+1)^4}{\left[\begin{array}[l]
                     \;&\left(\gamma^4+\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)+\gamma(\alpha+\beta)+1\right) & z^4 \\ 
                     +&\left(-4\gamma^4-2\gamma^3(\alpha+\beta)+2\gamma(\alpha+\beta)+4\right)                    & z^3 \\ 
                     +&\left(6\gamma^4-2\gamma^2(\alpha\beta+2)+6\right) & z^2 \\ 
                     +&\left(-4\gamma^4+2\gamma^3(\alpha+\beta)-2\gamma(\alpha+\beta)+4\right) & z \\
                     +&\left(\gamma^4-\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)-\gamma(\alpha+\beta)+1\right)
                     \end{array} \right]} \\[1em]
                     \triangleq \;\;& \frac{b_0+b_1z^{-1}+b_2z^{-2}+b_3z^{-3}+b_4z^{-4}}
                                           {a_0+a_1z^{-1}+a_2z^{-2}+a_3z^{-3}+a_4z^{-4}}
        \end{split}
    $$
    $$ \begin{split}
        b_0 \;\;= \;\;& 1 \\
        b_1 \;\;= \;\;& 4 \\
        b_2 \;\;= \;\;& 6 \\
        b_3 \;\;= \;\;& 4 \\
        b_4 \;\;= \;\;& 1 \\[0.6em]
        a_0 \;\;= \;\;& \gamma^4+\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)+\gamma(\alpha+\beta)+1 \quad\approx 97.95 \\
        a_1 \;\;= \;\;& -4\gamma^4-2\gamma^3(\alpha+\beta)+2\gamma(\alpha+\beta)+4 \quad\approx -192.8 \\
        a_2 \;\;= \;\;& 6\gamma^4-2\gamma^2(\alpha\beta+2)+6 \quad\approx 170.0 \\
        a_3 \;\;= \;\;& -4\gamma^4+2\gamma^3(\alpha+\beta)-2\gamma(\alpha+\beta)+4 \quad\approx -70.96 \\
        a_4 \;\;= \;\;& \gamma^4-\gamma^3(\alpha+\beta)+\gamma^2(\alpha\beta+2)-\gamma(\alpha+\beta)+1 \quad\approx 11.79 \\
    \end{split} $$
</p>

<h3>Frequency Response &amp; Pole-Zero Map</h3>

<p>
    We can check the filter's frequency response to make sure that we didn't make any mistakes. 
    As mentioned in other pages, the frequency response of a digital system can be a obtained by evaluating the 
    transfer function \(H(z)\) along the unit circle (\(z=e^{j\omega}\)). We'll plot the magnitude in decibels.
    $$ A(\omega) = 20 \log_{10}\left|H\left(e^{j\omega}\right)\right| $$
    We can also plot the phase angle of the response:
    $$ \phi(\omega) = \angle H\left(e^{j\omega}\right) $$
    <img src="images/Bode-Digital-Butterworth.svg">
    <img src="images/pz-butter.svg">
    You can see that the corner frequency lies around \(45 \;\mathrm{Hz}\). We can check this mathematically:
    $$ A(\omega_{c,d}) = -3.01 \mathrm{dB} $$
</p>

<h3>MATLAB & GNU Octave</h3>

<p>
    If you have to design many different filters, you don't want to calculate them all by hand. 
    Luckily, MATLAB and GNU Octave come with a command to calculate the coefficients of Butterworth filters.
</p>
<pre class="lineNumbers" style="color: rgb(0, 0, 0); /* background-color: rgb(255, 255, 255); */"><code><span style="color: #000000;">f_s = </span><span style="color: #09885a;">360</span><span style="color: #000000;">;    </span><span style="color: #008000;">% Sample frequency in Hz</span></code>
<code><span style="color: #000000;">f_c = </span><span style="color: #09885a;">45</span><span style="color: #000000;">;     </span><span style="color: #008000;">% Cut-off frequency in Hz</span></code>
<code><span style="color: #795e26;">order</span><span style="color: #000000;"> = </span><span style="color: #09885a;">4</span><span style="color: #000000;">;    </span><span style="color: #008000;">% Order of the butterworth filter</span></code>
<code></code>
<code><span style="color: #000000;">omega_c = </span><span style="color: #09885a;">2</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> </span><span style="color: #0000ff;">pi</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> f_c;       </span><span style="color: #008000;">% Cut-off angular frequency</span></code>
<code><span style="color: #000000;">omega_c_d = omega_c </span><span style="color: #000000;">/</span><span style="color: #000000;"> f_s;    </span><span style="color: #008000;">% Normalized cut-off frequency (digital)</span></code>
<code></code>
<code><span style="color: #000000;">[b, a] = </span><span style="color: #795e26;">butter</span><span style="color: #000000;">(</span><span style="color: #795e26;">order</span><span style="color: #000000;">, omega_c_d </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #0000ff;">pi</span><span style="color: #000000;">);    </span><span style="color: #008000;">% Design the Butterworth filter</span></code>
<code><span style="color: #0000ff;">disp</span><span style="color: #000000;">(</span><span style="color: #a31515;">'a = '</span><span style="color: #000000;">); </span><span style="color: #0000ff;">disp</span><span style="color: #000000;">(a);                     </span><span style="color: #008000;">% Print the coefficients</span></code>
<code><span style="color: #0000ff;">disp</span><span style="color: #000000;">(</span><span style="color: #a31515;">'b = '</span><span style="color: #000000;">); </span><span style="color: #0000ff;">disp</span><span style="color: #000000;">(b);</span></code>
<code><span style="color: #000000;">H = </span><span style="color: #795e26;">tf</span><span style="color: #000000;">(b, a, </span><span style="color: #09885a;">1</span><span style="color: #000000;"> </span><span style="color: #000000;">/</span><span style="color: #000000;"> f_s);                     </span><span style="color: #008000;">% Create a transfer function</span></code>
<code><span style="color: #795e26;">bode</span><span style="color: #000000;">(H);                                   </span><span style="color: #008000;">% Show the Bode plot</span></code></pre>
<p>
    Note that MATLAB expects the normalized frequency as a number from 0 to 1, so we have to divide by \(\pi\) 
    before passing it to the <code>butter</code> function.
</p>

<h3>Python</h3>

<p>
A similar function is available in the SciPy signal package:
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html"><code>butter</code></a>.

<pre class="lineNumbers" style="color: rgb(0, 0, 0); /* background-color: rgb(255, 255, 255); */"><code><span style="color: #af00db;">from</span><span style="color: #000000;"> scipy.signal </span><span style="color: #af00db;">import</span><span style="color: #000000;"> butter, freqz, freqs</span></code>
<code><span style="color: #af00db;">import</span><span style="color: #000000;"> matplotlib.pyplot </span><span style="color: #af00db;">as</span><span style="color: #000000;"> plt</span></code>
<code><span style="color: #af00db;">from</span><span style="color: #000000;"> math </span><span style="color: #af00db;">import</span><span style="color: #000000;"> pi</span></code>
<code><span style="color: #af00db;">import</span><span style="color: #000000;"> numpy </span><span style="color: #af00db;">as</span><span style="color: #000000;"> np</span></code>
<code></code>
<code><span style="color: #000000;">f_s </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">360</span><span style="color: #000000;">    </span><span style="color: #008000;"># Sample frequency in Hz</span></code>
<code><span style="color: #000000;">f_c </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">45</span><span style="color: #000000;">     </span><span style="color: #008000;"># Cut-off frequency in Hz</span></code>
<code><span style="color: #000000;">order </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">4</span><span style="color: #000000;">    </span><span style="color: #008000;"># Order of the butterworth filter</span></code>
<code></code>
<code><span style="color: #000000;">omega_c </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> pi </span><span style="color: #000000;">*</span><span style="color: #000000;"> f_c       </span><span style="color: #008000;"># Cut-off angular frequency</span></code>
<code><span style="color: #000000;">omega_c_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> omega_c </span><span style="color: #000000;">/</span><span style="color: #000000;"> f_s    </span><span style="color: #008000;"># Normalized cut-off frequency (digital)</span></code>
<code></code>
<code><span style="color: #008000;"># Design the digital Butterworth filter</span></code>
<code><span style="color: #000000;">b, a </span><span style="color: #000000;">=</span><span style="color: #000000;"> butter(order, omega_c_d </span><span style="color: #000000;">/</span><span style="color: #000000;"> pi)    </span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">'Coefficients'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"b ="</span><span style="color: #000000;">, b)                           </span><span style="color: #008000;"># Print the coefficients</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"a ="</span><span style="color: #000000;">, a)</span></code>
<code></code>
<code><span style="color: #000000;">w, H </span><span style="color: #000000;">=</span><span style="color: #000000;"> freqz(b, a, </span><span style="color: #09885a;">4096</span><span style="color: #000000;">)                  </span><span style="color: #008000;"># Calculate the frequency response</span></code>
<code><span style="color: #000000;">w </span><span style="color: #000000;">*=</span><span style="color: #000000;"> f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> (</span><span style="color: #09885a;">2</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> pi)                       </span><span style="color: #008000;"># Convert from rad/sample to Hz</span></code>
<code></code>
<code><span style="color: #008000;"># Plot the amplitude response</span></code>
<code><span style="color: #000000;">plt.subplot(</span><span style="color: #09885a;">2</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">)            </span></code>
<code><span style="color: #000000;">plt.suptitle(</span><span style="color: #a31515;">'Bode Plot'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">H_dB </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">20</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> np.log10(</span><span style="color: #795e26;">abs</span><span style="color: #000000;">(H))              </span><span style="color: #008000;"># Convert modulus of H to dB</span></code>
<code><span style="color: #000000;">plt.plot(w, H_dB)</span></code>
<code><span style="color: #000000;">plt.ylabel(</span><span style="color: #a31515;">'Magnitude [dB]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.xlim(</span><span style="color: #09885a;">0</span><span style="color: #000000;">, f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylim(</span><span style="color: #000000;">-</span><span style="color: #09885a;">80</span><span style="color: #000000;">, </span><span style="color: #09885a;">6</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.axvline(f_c, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'red'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.axhline(</span><span style="color: #000000;">-</span><span style="color: #09885a;">3</span><span style="color: #000000;">, </span><span style="color: #001080;">linewidth</span><span style="color: #000000;">=</span><span style="color: #09885a;">0.8</span><span style="color: #000000;">, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'black'</span><span style="color: #000000;">, </span><span style="color: #001080;">linestyle</span><span style="color: #000000;">=</span><span style="color: #a31515;">':'</span><span style="color: #000000;">)</span></code>
<code></code>
<code><span style="color: #008000;"># Plot the phase response</span></code>
<code><span style="color: #000000;">plt.subplot(</span><span style="color: #09885a;">2</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">, </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">phi </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.angle(H)                         </span><span style="color: #008000;"># Argument of H</span></code>
<code><span style="color: #000000;">phi </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.unwrap(phi)                      </span><span style="color: #008000;"># Remove discontinuities </span></code>
<code><span style="color: #000000;">phi </span><span style="color: #000000;">*=</span><span style="color: #000000;"> </span><span style="color: #09885a;">180</span><span style="color: #000000;"> </span><span style="color: #000000;">/</span><span style="color: #000000;"> pi                           </span><span style="color: #008000;"># and convert to degrees</span></code>
<code><span style="color: #000000;">plt.plot(w, phi)</span></code>
<code><span style="color: #000000;">plt.xlabel(</span><span style="color: #a31515;">'Frequency [Hz]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylabel(</span><span style="color: #a31515;">'Phase [°]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.xlim(</span><span style="color: #09885a;">0</span><span style="color: #000000;">, f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylim(</span><span style="color: #000000;">-</span><span style="color: #09885a;">360</span><span style="color: #000000;">, </span><span style="color: #09885a;">0</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.yticks([</span><span style="color: #000000;">-</span><span style="color: #09885a;">360</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">270</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">180</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">90</span><span style="color: #000000;">, </span><span style="color: #09885a;">0</span><span style="color: #000000;">])</span></code>
<code><span style="color: #000000;">plt.axvline(f_c, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'red'</span><span style="color: #000000;">)</span></code>
<code></code>
<code><span style="color: #000000;">plt.show()</span></code></pre>

<img src="images/Bode-Digital-Butterworth-Python-3.svg">

<h3>Comparison Between the Analog and Digital Filter</h3>

<p>
    We can easily plot the Bode plots of the two filters on top of each other, in order to compare their properties.
</p>
<pre class="lineNumbers" style="color: rgb(0, 0, 0); /* background-color: rgb(255, 255, 255); */"><code><span style="color: #af00db;">from</span><span style="color: #000000;"> scipy.signal </span><span style="color: #af00db;">import</span><span style="color: #000000;"> butter, freqz, freqs</span></code>
<code><span style="color: #af00db;">import</span><span style="color: #000000;"> matplotlib.pyplot </span><span style="color: #af00db;">as</span><span style="color: #000000;"> plt</span></code>
<code><span style="color: #af00db;">from</span><span style="color: #000000;"> math </span><span style="color: #af00db;">import</span><span style="color: #000000;"> pi</span></code>
<code><span style="color: #af00db;">import</span><span style="color: #000000;"> numpy </span><span style="color: #af00db;">as</span><span style="color: #000000;"> np</span></code>
<code></code>
<code><span style="color: #000000;">f_s </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">360</span><span style="color: #000000;">    </span><span style="color: #008000;"># Sample frequency in Hz</span></code>
<code><span style="color: #000000;">f_c </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">45</span><span style="color: #000000;">     </span><span style="color: #008000;"># Cut-off frequency in Hz</span></code>
<code><span style="color: #000000;">order </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">4</span><span style="color: #000000;">    </span><span style="color: #008000;"># Order of the butterworth filter</span></code>
<code></code>
<code><span style="color: #000000;">omega_c </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> pi </span><span style="color: #000000;">*</span><span style="color: #000000;"> f_c       </span><span style="color: #008000;"># Cut-off angular frequency</span></code>
<code><span style="color: #000000;">omega_c_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> omega_c </span><span style="color: #000000;">/</span><span style="color: #000000;"> f_s    </span><span style="color: #008000;"># Normalized cut-off frequency (digital)</span></code>
<code></code>
<code><span style="color: #008000;"># Design the digital Butterworth filter</span></code>
<code><span style="color: #000000;">b_d, a_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> butter(order, omega_c_d </span><span style="color: #000000;">/</span><span style="color: #000000;"> pi)    </span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">'Digital Coefficients'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"b ="</span><span style="color: #000000;">, b_d)                         </span><span style="color: #008000;"># Print the coefficients</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"a ="</span><span style="color: #000000;">, a_d)</span></code>
<code></code>
<code><span style="color: #000000;">w, H_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> freqz(b_d, a_d, </span><span style="color: #09885a;">4096</span><span style="color: #000000;">)            </span><span style="color: #008000;"># Calculate the frequency response</span></code>
<code><span style="color: #000000;">w </span><span style="color: #000000;">*=</span><span style="color: #000000;"> f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> (</span><span style="color: #09885a;">2</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> pi)                       </span><span style="color: #008000;"># Convert from rad/sample to Hz</span></code>
<code></code>
<code><span style="color: #008000;"># Design the analog Butterworth filter</span></code>
<code><span style="color: #000000;">b_a, a_a </span><span style="color: #000000;">=</span><span style="color: #000000;"> butter(order, f_c, </span><span style="color: #001080;">analog</span><span style="color: #000000;">=</span><span style="color: #0000ff;">True</span><span style="color: #000000;">)</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">'Analog Coefficients'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"b ="</span><span style="color: #000000;">, b_a)                         </span><span style="color: #008000;"># Print the coefficients</span></code>
<code><span style="color: #795e26;">print</span><span style="color: #000000;">(</span><span style="color: #a31515;">"a ="</span><span style="color: #000000;">, a_a)</span></code>
<code></code>
<code><span style="color: #000000;">w, H_a </span><span style="color: #000000;">=</span><span style="color: #000000;"> freqs(b_a, a_a, w)               </span><span style="color: #008000;"># Calculate the frequency response</span></code>
<code></code>
<code><span style="color: #008000;"># Plot the amplitude response</span></code>
<code><span style="color: #000000;">plt.subplot(</span><span style="color: #09885a;">2</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">)            </span></code>
<code><span style="color: #000000;">plt.suptitle(</span><span style="color: #a31515;">'Bode Plot'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">H_d_dB </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">20</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> np.log10(</span><span style="color: #795e26;">abs</span><span style="color: #000000;">(H_d))          </span><span style="color: #008000;"># Convert modulus of H to dB</span></code>
<code><span style="color: #000000;">H_a_dB </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #09885a;">20</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> np.log10(</span><span style="color: #795e26;">abs</span><span style="color: #000000;">(H_a))</span></code>
<code><span style="color: #000000;">plt.plot(w, H_d_dB, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'blue'</span><span style="color: #000000;">, </span><span style="color: #001080;">label</span><span style="color: #000000;">=</span><span style="color: #a31515;">'Digital'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.plot(w, H_a_dB, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'green'</span><span style="color: #000000;">, </span><span style="color: #001080;">label</span><span style="color: #000000;">=</span><span style="color: #a31515;">'Analog'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.legend()</span></code>
<code><span style="color: #000000;">plt.ylabel(</span><span style="color: #a31515;">'Magnitude [dB]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.xlim(</span><span style="color: #09885a;">0</span><span style="color: #000000;">, f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylim(</span><span style="color: #000000;">-</span><span style="color: #09885a;">80</span><span style="color: #000000;">, </span><span style="color: #09885a;">6</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.axvline(f_c, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'red'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.axhline(</span><span style="color: #000000;">-</span><span style="color: #09885a;">3</span><span style="color: #000000;">, </span><span style="color: #001080;">linewidth</span><span style="color: #000000;">=</span><span style="color: #09885a;">0.8</span><span style="color: #000000;">, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'black'</span><span style="color: #000000;">, </span><span style="color: #001080;">linestyle</span><span style="color: #000000;">=</span><span style="color: #a31515;">':'</span><span style="color: #000000;">)</span></code>
<code></code>
<code><span style="color: #008000;"># Plot the phase response</span></code>
<code><span style="color: #000000;">plt.subplot(</span><span style="color: #09885a;">2</span><span style="color: #000000;">, </span><span style="color: #09885a;">1</span><span style="color: #000000;">, </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">phi_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.angle(H_d)                     </span><span style="color: #008000;"># Argument of H</span></code>
<code><span style="color: #000000;">phi_a </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.angle(H_a)</span></code>
<code><span style="color: #000000;">phi_d </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.unwrap(phi_d) </span><span style="color: #000000;">*</span><span style="color: #000000;"> </span><span style="color: #09885a;">180</span><span style="color: #000000;"> </span><span style="color: #000000;">/</span><span style="color: #000000;"> pi       </span><span style="color: #008000;"># Remove discontinuities</span></code>
<code><span style="color: #000000;">phi_a </span><span style="color: #000000;">=</span><span style="color: #000000;"> np.unwrap(phi_a) </span><span style="color: #000000;">*</span><span style="color: #000000;"> </span><span style="color: #09885a;">180</span><span style="color: #000000;"> </span><span style="color: #000000;">/</span><span style="color: #000000;"> pi       </span><span style="color: #008000;"># and convert to degrees</span></code>
<code><span style="color: #000000;">plt.plot(w, phi_d, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'blue'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.plot(w, phi_a, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'green'</span><span style="color: #000000;">)  </span></code>
<code><span style="color: #000000;">plt.xlabel(</span><span style="color: #a31515;">'Frequency [Hz]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylabel(</span><span style="color: #a31515;">'Phase [°]'</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.xlim(</span><span style="color: #09885a;">0</span><span style="color: #000000;">, f_s </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #09885a;">2</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.ylim(</span><span style="color: #000000;">-</span><span style="color: #09885a;">360</span><span style="color: #000000;">, </span><span style="color: #09885a;">0</span><span style="color: #000000;">)</span></code>
<code><span style="color: #000000;">plt.yticks([</span><span style="color: #000000;">-</span><span style="color: #09885a;">360</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">270</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">180</span><span style="color: #000000;">, </span><span style="color: #000000;">-</span><span style="color: #09885a;">90</span><span style="color: #000000;">, </span><span style="color: #09885a;">0</span><span style="color: #000000;">])</span></code>
<code><span style="color: #000000;">plt.axvline(f_c, </span><span style="color: #001080;">color</span><span style="color: #000000;">=</span><span style="color: #a31515;">'red'</span><span style="color: #000000;">)</span></code>
<code></code>
<code><span style="color: #000000;">plt.show()</span></code></pre>
<img src="images/Bode-Butter-4-Compare-Digital-Analog.svg">

<h2>Discretization using Second Order Sections (SOS)</h2>

<p>
    For higher order filters, small quantization errors on the transfer function
    coefficients can result in large errors on the pole and zero locations.<br>
    A solution is to factor the transfer function into second order factors or
    sections.
</p>
<p>
Recall from the previous sections, and define \(\alpha_k\), \(H_{2,k}\) and 
\(H_{1}\) as follows:
$$
\begin{align}
\gamma \;\triangleq\; &amp; \cot\left(\pi\frac{f_c}{f_s}\right)\\

s' \;\triangleq\; &amp; \frac{s}{\omega_{c,a}} = \gamma \frac{z-1}{z+1}
\label{s_prime} \\

\alpha_k \;\triangleq\; &amp; 2 \cos\left(2\pi\frac{2k + n + 1}{4n}\right)\\

H_{2,k}\left(s'\right) \;\triangleq\; &amp;  \frac{1}{B_{2,k}\left(s'\right)} 
                       \triangleq \frac{1}{s'^2 - \alpha_k s' + 1} 
                       \label{sos_s_prime} \\

H_{1}\left(s'\right) \;\triangleq\; &amp;  \frac{1}{s'+1} \\

H_n\left(s'\right) \;=\; &amp; \begin{cases}
\prod_{k=0}^{\frac{n}{2}-1} H_{2,k}\left(s'\right)  &amp;
\textrm{even}\ n \\
H_{1}\left(s'\right) \prod_{k=0}^{\frac{n-1}{2}-1} H_{2,k}\left(s'\right)  &amp;
\textrm{odd}\ n \\
\end{cases}
\end{align}
$$
</p>

<h3>Second Order Sections</h3>

<p>
We'll use the same technique as before to substitute \(s'\) into 
\(B_{2,k}\left(s'\right)\) using the pre-warped bilinear transform relation 
\(\ref{s_prime}\) to get the discrete-time Butterworth polynomial 
\(B_{2,k}\left(z\right)\):

$$
\begin{split}
B_{2,k}\left(s'\right) \;\triangleq\; &amp; 
                        s'^2 - \alpha_k s' + 1 \\
B_{2,k}\left(z\right)  \;=\; &amp; 
    \gamma^2 \left(\frac{z-1}{z+1}\right)^2 - \alpha_k \gamma \frac{z-1}{z+1} + 1 \\
                       \;=\; &amp; 
    \gamma^2 \frac{\left(z-1\right)^2}{\left(z+1\right)^2} 
  - \alpha_k \gamma \frac{\left(z-1\right)\left(z+1\right)}{\left(z+1\right)^2}
  + \frac{\left(z+1\right)^2}{\left(z+1\right)^2} \\
                       \;=\; &amp; 
    \frac{\gamma^2 \left(z-1\right)^2 
  - \alpha_k \gamma \left(z-1\right)\left(z+1\right)
  + \left(z+1\right)^2}{\left(z+1\right)^2} \\
                       \;=\; &amp; 
    \frac{\left(\gamma^2 - \alpha_k \gamma + 1\right) z^2
  - \left(2 \gamma^2 - 2\right) z 
  + \left(\gamma^2 + \alpha_k \gamma + 1\right)}
    {\left(z+1\right)^2} \\
H_{2,k}\left(z\right)  \;=\; &amp; 
    \frac{z^2 + 2 z + 1}
        {\left(\gamma^2 - \alpha_k \gamma + 1\right) z^2
        - \left(2 \gamma^2 - 2\right) z 
        + \left(\gamma^2 + \alpha_k \gamma + 1\right)} \\
                       \;=\; &amp; 
    \frac{1 + 2 z^{-1} + z^{-2}}
        {\left(\gamma^2 - \alpha_k \gamma + 1\right)
        - \left(2 \gamma^2 - 2\right) z^{-1}
        + \left(\gamma^2 + \alpha_k \gamma + 1\right) z^{-2}}
\end{split}
$$
The coefficients of the \(k\)-th factor of the discrete-time transfer function 
are thus:
$$ \begin{split}
    b_{k,0} \;\;= \;\;&amp; 1 \\
    b_{k,1} \;\;= \;\;&amp; 2 \\
    b_{k,2} \;\;= \;\;&amp; 1 \\[0.6em]
    a_{k,0} \;\;= \;\;&amp; \gamma^2 - \alpha_k \gamma + 1 \\
    a_{k,1} \;\;= \;\;&amp; 2 \left(1 - \gamma^2\right) \\
    a_{k,2} \;\;= \;\;&amp; \gamma^2 + \alpha_k \gamma + 1 \\
\end{split} $$
</p>

<h3>First Order Section</h3>

<p>
    For odd orders \(n\), we need \(\frac{n-1}{2}\) second order sections and a 
    single first order section.
</p>

Again, we'll use the the pre-warped bilinear transform relation 
\(\ref{s_prime}\):

$$ \begin{split} 
H_1\left(s'\right) \;\triangleq\; &amp; \frac{1}{s'+1} \\
\;=\; &amp; \frac{1}{\gamma \frac{z-1}{z+1} + 1} \\
\;=\; &amp; \frac{z+1}{\gamma \left(z-1\right) + \left(z+1\right)} \\
\;=\; &amp; \frac{z+1}{\left(\gamma + 1\right) z + \left(1 - \gamma\right)} \\
\;=\; &amp; \frac{1 + z^{-1}}
                 {\left(\gamma + 1\right) + \left(1 - \gamma\right) z^{-1}} \\
\end{split} $$ 

This gives us the coefficients of the first order factor of the discrete-time
transfer function:
$$ \begin{split}
    b_{0} \;\;= \;\;&amp; 1 \\
    b_{1} \;\;= \;\;&amp; 1 \\[0.6em]
    a_{0} \;\;= \;\;&amp; \gamma + 1 \\
    a_{1} \;\;= \;\;&amp; 1 - \gamma \\
\end{split} $$
</p>

</html>